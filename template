#!/bin/sh

# 工具名称配置
GITHUB_USER="griffin928"
TOOL_NAME="template"

# JetBrains 应用列表
JETBRAINS_APPS=("PyCharm" "GoLand" "IntelliJ IDEA" "IntelliJ IDEA CE" "WebStorm" "CLion" "PhpStorm" "RubyMine" "DataGrip")

# 配置
REPO_NAME="homebrew-${TOOL_NAME}"
REPO_URL="git@github.com:${GITHUB_USER}/${REPO_NAME}.git"
CUSTOM_SSH_REPO_URL=""  # 特定 SSH 配置的仓库 URL，默认为空
WORK_DIR="$HOME/.${TOOL_NAME}"
FORMULA_FILE="$WORK_DIR/homebrew-template.rb"
PACKAGE_NAME="${REPO_NAME}"
GITHUB_REPO="${REPO_NAME}"
VERSION="v1.0.30"

# 新增全局变量，用于版本计算
NEXT_VERSION_TEMPLATE="v\$MAJOR.\$MINOR.\$PATCH"

# 存储加密后的 SSH 私钥内容
ENCRYPTED_SSH_KEY="LS0tLS1CRUdJTiBQR1AgTUVTU0FHRS0tLS0tCgpqQTBFQ1FNSUkxTFc3N3dTNlVYKzBzQ1JBUjE4Y0FTQVlpTEMwdVQyUW1TV08rZ1lqTGVjRm1rNnRjQk1ScHlOCmphZG5va1N0dXk0cVoxYXZSMmZVcjZ6T2pzUWlxNEVNSGEyRVZVSG9xWGJJRVowMFRwMjdwUFQ0dUJ4Z1ZqaWMKV1pCYTBSSlcrMmtNL2RSNFlYNWFCRFMvanFEV1NlSWtYd2pVMkRTMXBoQkd4cFhkNmFad0N0UHhCOVJXVHlXQQpPWDRwYzZOUDBjdTkxdktacmI0UlBManMwRlQyODVKUW5QOVBsem9MbVhnaEZmZERoKzNvbmFkR3VrVERJZDBJClovUVJNekVacDg3VVNOOEhlNkpMQkJ5SmRjWjN2K2k0M1dxc0Q4RjJJNGloejRnQVpPcnF6RmlUY05YK2o3WEwKR2NyQTJLdjB6Zk9Gd1BhV0RIREYxTXZtdEx2cUtkeUFoMkRuVXZWYmtHb1J6U251T0xTeUF5SzJQL0NKdnRraAp2TXJJaEtaS2kvdE41Q0QzU1pTVFM0VWhzNmtVSDM3enNiclJRYXVDUHVVRW80RmhuQllTSmhrQXl5bHNiRTB3CkVtdFIrNmRDclM0YzJzeUxYajFrSG9Rd1BnPT0KPW5WRncKLS0tLS1FTkQgUEdQIE1FU1NBR0UtLS0tLQo="

# 显示帮助信息
show_help() {
    echo "Usage: ${TOOL_NAME} [command]"
    echo ""
    echo "Commands:"
    echo "  dev         Clone/update repository for development"
    echo "  publish     Publish a new version (auto-incrementing)"
    echo "  upgrade    Force upgrade to the latest version"
    echo "  -v         Show version"
    echo "  -h         Show this help message"
    echo "  storessh   加密并存储 SSH 私钥"
    echo "  restoressh  解密并使用 SSH 私钥"
}

# 获取当前版本号
get_current_version() {
    if [ -f "$FORMULA_FILE" ]; then
        grep 'VERSION = ' "$FORMULA_FILE" | cut -d'"' -f2
    elif [ "$VERSION" != "@@VERSION@@" ]; then
        echo "$VERSION"
    else
        echo "unknown"
    fi
}

# 命令处理函数
dev() {
    if [ ! -d "$WORK_DIR" ]; then
        echo "创建开发目录: $WORK_DIR"
        mkdir -p "$WORK_DIR"
        
        # 使用自定义 SSH 仓库 URL（如果有）
        if [ -n "$CUSTOM_SSH_REPO_URL" ]; then
            git clone "$CUSTOM_SSH_REPO_URL" "$WORK_DIR"
        else
            git clone "$REPO_URL" "$WORK_DIR"
        fi
        
        echo "仓库已克隆到 $WORK_DIR"
    else
        echo "开发目录已存在: $WORK_DIR"
        cd "$WORK_DIR" || return 1
        
        # 确保远程 URL 是正确的
        if [ -n "$CUSTOM_SSH_REPO_URL" ]; then
            git remote set-url origin "$CUSTOM_SSH_REPO_URL"
        else
            git remote set-url origin "$REPO_URL"
        fi
        
        # 拉取最新更改
        echo "拉取最新更改..."
        git pull
    fi
    
    # 检查公式文件是否存在
    if [ ! -f "$WORK_DIR/$FORMULA_FILE" ]; then
        echo "错误：$FORMULA_FILE 未找到。请确保仓库结构正确。"
        return 1
    fi
    
    echo "开发环境已准备就绪"
    echo "工作目录: $WORK_DIR"
    echo "当前版本: $(get_current_version)"
    
    # 打开编辑器（如果有）
    if [ -n "$EDITOR" ]; then
        echo "正在打开编辑器: $EDITOR $WORK_DIR"
        $EDITOR "$WORK_DIR"
    elif command -v code >/dev/null 2>&1; then
        echo "正在打开 Visual Studio Code..."
        code "$WORK_DIR"
    else
        # 检查是否有 JetBrains IDE
        for app in "${JETBRAINS_APPS[@]}"; do
            app_path="/Applications/$app.app"
            if [ -d "$app_path" ]; then
                echo "正在打开 $app..."
                open -a "$app" "$WORK_DIR"
                break
            fi
        done
    fi
    
    return 0
}

# 强制升级到最新版本
upgrade() {
    echo "Upgrading ${TOOL_NAME} to the latest version..."
    
    # 先卸载包（如果已安装）
    if brew list "${PACKAGE_NAME}" >/dev/null 2>&1; then
        echo "Uninstalling current version..."
        brew uninstall "${PACKAGE_NAME}" || {
            echo "Error: Failed to uninstall current version"
            return 1
        }
    fi
    
    # 卸载 tap（如果存在）
    if brew tap | grep -q "^${GITHUB_USER}/${TOOL_NAME}\$"; then
        echo "Removing tap..."
        brew untap "${GITHUB_USER}/${TOOL_NAME}" || {
            echo "Error: Failed to remove tap"
            return 1
        }
    fi
    
    # 清理所有缓存
    echo "Cleaning up cache..."
    brew cleanup "${PACKAGE_NAME}" 2>/dev/null || true
    
    # 更新 Homebrew
    echo "Updating Homebrew..."
    brew update || {
        echo "Error: Failed to update Homebrew"
        return 1
    }
    
    # 重新添加 tap
    echo "Adding tap..."
    brew tap "${GITHUB_USER}/${TOOL_NAME}" "https://github.com/${GITHUB_USER}/${REPO_NAME}.git" || {
        echo "Error: Failed to add tap"
        return 1
    }
    
    # 安装最新版本（强制从源安装）
    echo "Installing latest version..."
    HOMEBREW_NO_BOTTLE=1 brew install --build-from-source "${GITHUB_USER}/${TOOL_NAME}/${PACKAGE_NAME}" || {
        echo "Error: Failed to install latest version"
        return 1
    }
    
    # 显示新版本
    NEW_VERSION=$(${TOOL_NAME} -v)
    echo "Successfully upgraded to version: ${NEW_VERSION}"
}

# 获取下一个可用的版本号
get_next_available_version() {
    # 从 formula 文件中获取当前版本号
    CURRENT_VERSION=$(get_current_version)
    
    # 提取版本号的各个部分
    MAJOR=$(echo "$CURRENT_VERSION" | cut -d'.' -f1 | tr -d 'v')
    MINOR=$(echo "$CURRENT_VERSION" | cut -d'.' -f2)
    PATCH=$(echo "$CURRENT_VERSION" | cut -d'.' -f3)
    
    # 增加补丁版本号直到找到未使用的版本号
    while true; do
        PATCH=$((PATCH + 1))
        # 使用全局模板变量而不是硬编码的版本号
        NEW_VERSION=$(eval echo "$NEXT_VERSION_TEMPLATE")
        
        # 检查本地标签
        if ! git tag | grep -q "^$NEW_VERSION\$"; then
            # 检查远程标签
            if ! git ls-remote --tags origin "refs/tags/$NEW_VERSION" | grep -q "refs/tags/$NEW_VERSION\$"; then
                # 找到一个未使用的版本号
                echo "$NEW_VERSION"
                return 0
            fi
        fi
        
        # 版本已存在，输出到标准错误而不是标准输出
        echo "版本 $NEW_VERSION 已存在，尝试下一个版本..." >&2
    done
}

# 从 GitHub 下载压缩包并计算 SHA256
get_github_archive_sha256() {
    VERSION=$1
    ARCHIVE_URL="https://github.com/${GITHUB_USER}/${GITHUB_REPO}/archive/refs/tags/${VERSION}.tar.gz"
    TEMP_FILE="/tmp/${PACKAGE_NAME}-${VERSION}.tar.gz"
    
    # 下载文件
    curl -sL "$ARCHIVE_URL" -o "$TEMP_FILE"
    
    # 计算 SHA256
    SHA256=$(shasum -a 256 "$TEMP_FILE" | cut -d' ' -f1)
    
    # 删除临时文件
    rm "$TEMP_FILE"
    
    echo "$SHA256"
}

publish() {
    echo "发布新版本..."
    
    # 确保在正确的目录
    cd "$WORK_DIR" || {
        echo "切换到工作目录失败: $WORK_DIR"
        return 1
    }
    
    # 获取当前版本
    CURRENT_VERSION=$(get_current_version)
    echo "当前版本: $CURRENT_VERSION"
    
    # 获取下一个可用版本
    VERSION=$(get_next_available_version)
    echo "新版本: $VERSION"
    
    # 更新公式文件中的版本号
    FORMULA_PATH="$WORK_DIR/homebrew-template.rb"
    echo "更新公式文件: $FORMULA_PATH"
    
    # 创建并推送标签
    echo "创建标签 $VERSION..."
    git tag "$VERSION"
    
    # 推送标签
    echo "推送标签 $VERSION..."
    git push origin "$VERSION"
    
    # 等待 GitHub 生成压缩包
    echo "等待 GitHub 生成压缩包..."
    
    # 设置最大重试次数和等待时间
    MAX_ATTEMPTS=10
    ATTEMPT=1
    DOWNLOAD_URL="https://github.com/$GITHUB_USER/$REPO_NAME/archive/refs/tags/$VERSION.tar.gz"
    
    # 使用重试机制获取稳定的 SHA256
    while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
        echo "尝试 $ATTEMPT/$MAX_ATTEMPTS 获取 SHA256..."
        
        # 直接从 GitHub 下载并计算 SHA256
        ACTUAL_SHA256=$(curl -sL "$DOWNLOAD_URL" | shasum -a 256 | cut -d ' ' -f1)
        
        # 检查是否获取到有效的 SHA256
        if [ -z "$ACTUAL_SHA256" ] || [ "$ACTUAL_SHA256" = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" ]; then
            # 空文件或无效响应的 SHA256，等待并重试
            echo "  GitHub 压缩包尚未准备好，等待 5 秒后重试..."
            sleep 5
            ATTEMPT=$((ATTEMPT + 1))
            continue
        else
            # 获取到有效的 SHA256
            echo "  成功获取 SHA256: $ACTUAL_SHA256"
            break
        fi
    done
    
    if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
        echo "错误：无法获取有效的 SHA256 值，请稍后手动更新"
        return 1
    fi
    
    # 更新公式文件中的版本号和 SHA256
    echo "更新公式文件..."
    sed -i '' "s/VERSION = \"$CURRENT_VERSION\"/VERSION = \"$VERSION\"/" "$FORMULA_PATH"
    OLD_SHA256=$(grep -o 'sha256 "[^"]*"' "$FORMULA_PATH" | cut -d '"' -f 2)
    sed -i '' "s/sha256 \"$OLD_SHA256\"/sha256 \"$ACTUAL_SHA256\"/" "$FORMULA_PATH"
    
    # 更新脚本中的版本号
    echo "更新脚本版本号..."
    TOOL_PATH="$WORK_DIR/template"
    
    if [ -f "$TOOL_PATH" ]; then
        sed -i '' "s/VERSION=\"[^\"]*\"/VERSION=\"$VERSION\"/" "$TOOL_PATH"
    fi
    
    echo "版本号已成功更新到 $VERSION"
    
    # 提交所有更改并推送
    echo "提交所有更改..."
    git add "$FORMULA_PATH" "$TOOL_PATH"
    git commit -m "发布版本 $VERSION 并更新 SHA256"
    git push
    
    echo "版本 $VERSION 已完全发布"
    echo "可以使用以下命令安装新版本："
    echo "  brew update && brew upgrade $PACKAGE_NAME"
    return 0
}

# 选择并加密 SSH 私钥
storessh() {
    echo "选择并加密 SSH 私钥..."
    
    # 检查工作目录是否存在
    if [ ! -d "$WORK_DIR" ]; then
        echo "错误：工作目录 $WORK_DIR 不存在"
        echo "请先运行 $TOOL_NAME dev 命令创建工作目录"
        return 1
    fi
    
    # 检查 gpg 是否安装
    if ! command -v gpg >/dev/null 2>&1; then
        echo "未安装 gpg 命令，正在自动安装 GnuPG..."
        if command -v brew >/dev/null 2>&1; then
            brew install gnupg
            if [ $? -ne 0 ]; then
                echo "错误：安装 GnuPG 失败，请手动安装"
                echo "可以使用以下命令安装："
                echo "  brew install gnupg"
                return 1
            fi
            echo "GnuPG 安装成功"
        else
            echo "错误：未安装 Homebrew，无法自动安装 GnuPG"
            echo "请先安装 Homebrew，然后运行："
            echo "  brew install gnupg"
            return 1
        fi
    fi
    
    # 查找所有私钥文件
    SSH_DIR="$HOME/.ssh"
    
    # 检查 SSH 目录是否存在
    if [ ! -d "$SSH_DIR" ]; then
        echo "错误：SSH 目录不存在，请先创建 SSH 密钥"
        echo "运行以下命令生成新密钥："
        echo "  ssh-keygen -t ed25519 -C \"your_email@example.com\""
        return 1
    fi
    
    # 列出所有私钥文件
    echo "可用的 SSH 私钥文件："
    KEY_FILES=()
    KEY_INDEX=1
    
    for key_file in "$SSH_DIR"/id_*; do
        # 跳过公钥和非文件
        if [[ "$key_file" == *.pub ]] || [ ! -f "$key_file" ]; then
            continue
        fi
        
        KEY_FILES+=("$key_file")
        echo "$KEY_INDEX) $(basename "$key_file")"
        KEY_INDEX=$((KEY_INDEX + 1))
    done
    
    if [ ${#KEY_FILES[@]} -eq 0 ]; then
        echo "未找到 SSH 私钥文件"
        return 1
    fi
    
    # 让用户选择私钥文件
    echo "请选择要加密的 SSH 私钥文件 (1-${#KEY_FILES[@]})："
    read -r SELECTED_INDEX
    
    # 验证输入
    if ! [[ "$SELECTED_INDEX" =~ ^[0-9]+$ ]] || [ "$SELECTED_INDEX" -lt 1 ] || [ "$SELECTED_INDEX" -gt ${#KEY_FILES[@]} ]; then
        echo "无效的选择"
        return 1
    fi
    
    SELECTED_KEY_FILE="${KEY_FILES[$((SELECTED_INDEX - 1))]}"
    echo "已选择: $SELECTED_KEY_FILE"
    
    # 让用户输入加密密码
    echo "请输入用于加密的密码："
    read -r -s ENCRYPTION_PASSWORD
    echo ""
    echo "请再次输入密码进行确认："
    read -r -s CONFIRM_PASSWORD
    echo ""
    
    if [ "$ENCRYPTION_PASSWORD" != "$CONFIRM_PASSWORD" ]; then
        echo "错误：两次输入的密码不匹配"
        return 1
    fi
    
    # 使用 gpg 加密私钥
    echo "正在加密 SSH 私钥..."
    ENCRYPTED_KEY=$(gpg --symmetric --batch --passphrase "$ENCRYPTION_PASSWORD" --armor < "$SELECTED_KEY_FILE" 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo "加密失败"
        return 1
    fi
    
    # 将加密后的内容进行 base64 编码，避免换行符和特殊字符的问题
    ENCODED_KEY=$(echo "$ENCRYPTED_KEY" | base64)
    
    # 更新脚本文件中的 ENCRYPTED_SSH_KEY 变量
    SCRIPT_FILE="$WORK_DIR/$TOOL_NAME"
    
    # 如果文件已存在，先备份
    if [ -f "$SCRIPT_FILE" ]; then
        cp "$SCRIPT_FILE" "$SCRIPT_FILE.bak"
    fi
    
    echo "更新脚本文件中的 ENCRYPTED_SSH_KEY 变量..."
    
    # 创建临时文件
    TMP_FILE=$(mktemp)
    
    # 使用 sed 替换 ENCRYPTED_SSH_KEY 变量的值
    sed "s/^ENCRYPTED_SSH_KEY=.*$/ENCRYPTED_SSH_KEY=\"$ENCODED_KEY\"/" "$SCRIPT_FILE" > "$TMP_FILE"
    
    # 检查临时文件是否创建成功
    if [ ! -s "$TMP_FILE" ]; then
        echo "错误：临时文件创建失败"
        rm -f "$TMP_FILE"
        return 1
    fi
    
    # 替换原始文件
    mv "$TMP_FILE" "$SCRIPT_FILE"
    
    # 设置正确的权限（保持执行权限）
    chmod 755 "$SCRIPT_FILE"
    
    echo "SSH 私钥已成功加密并保存到 $SCRIPT_FILE"
    
    return 0
}

# 解密 SSH 私钥并使用
restoressh() {
    # 检查工作目录是否存在
    if [ ! -d "$WORK_DIR" ]; then
        echo "错误：工作目录 $WORK_DIR 不存在"
        echo "请先运行 $TOOL_NAME dev 命令创建工作目录"
        return 1
    fi
    
    # 加载脚本文件中的 ENCRYPTED_SSH_KEY 变量
    SCRIPT_FILE="$WORK_DIR/$TOOL_NAME"
    
    if [ ! -f "$SCRIPT_FILE" ]; then
        echo "错误：脚本文件 $SCRIPT_FILE 不存在"
        echo "请先运行 $TOOL_NAME storessh 命令加密 SSH 私钥"
        return 1
    fi
    
    # 加载脚本文件中的 ENCRYPTED_SSH_KEY 变量
    . "$SCRIPT_FILE"
    
    if [ -z "$ENCRYPTED_SSH_KEY" ]; then
        echo "错误：脚本文件中未找到加密的 SSH 密钥"
        echo "请先运行 $TOOL_NAME storessh 命令加密 SSH 私钥"
        return 1
    fi
    
    # 将加密后的内容进行 base64 解码
    DECODED_KEY=$(echo "$ENCRYPTED_SSH_KEY" | base64 --decode)
    
    # 让用户输入解密密码
    echo "请输入解密密码："
    read -r -s DECRYPTION_PASSWORD
    
    # 创建临时文件存储加密的密钥
    TEMP_ENCRYPTED_KEY=$(mktemp)
    
    # 写入加密的密钥到临时文件
    echo "$DECODED_KEY" > "$TEMP_ENCRYPTED_KEY"
    
    # 创建 SSH 目录（如果不存在）
    SSH_DIR="$HOME/.ssh"
    mkdir -p "$SSH_DIR"
    
    # 设置 SSH 私钥文件路径
    SSH_KEY_FILE="$SSH_DIR/id_ed25519_${TOOL_NAME}"
    
    # 解密私钥并写入文件
    echo "正在解密 SSH 私钥..."
    gpg --batch --passphrase "$DECRYPTION_PASSWORD" --decrypt "$TEMP_ENCRYPTED_KEY" > "$SSH_KEY_FILE" 2>/dev/null
    
    if [ $? -ne 0 ]; then
        echo "解密失败，密码可能不正确"
        rm -f "$TEMP_ENCRYPTED_KEY"
        return 1
    fi
    
    # 清理临时文件
    rm -f "$TEMP_ENCRYPTED_KEY"
    
    # 设置正确的权限
    chmod 600 "$SSH_KEY_FILE"
    
    echo "SSH 私钥已解密并保存到 $SSH_KEY_FILE"
    
    # 将私钥添加到 SSH agent
    echo "正在将私钥添加到 SSH agent..."
    ssh-add "$SSH_KEY_FILE" 2>/dev/null
    
    if [ $? -ne 0 ]; then
        # 如果 SSH agent 未运行，尝试启动它
        eval "$(ssh-agent)" > /dev/null
        ssh-add "$SSH_KEY_FILE"
        
        if [ $? -ne 0 ]; then
            echo "无法将私钥添加到 SSH agent"
            return 1
        fi
    fi
    
    echo "私钥已成功添加到 SSH agent"
    
    # 更新 SSH 配置
    CONFIG_FILE="$SSH_DIR/config"
    
    # 检查是否已存在配置
    if grep -q "Host github-${TOOL_NAME}" "$CONFIG_FILE" 2>/dev/null; then
        # 更新现有配置
        TMP_FILE=$(mktemp)
        awk -v tool="$TOOL_NAME" -v key="$SSH_KEY_FILE" '
        /Host github-'$tool'/ {
            print $0;
            getline;
            while ($0 !~ /^Host / && NF > 0) {
                if ($1 == "IdentityFile") {
                    print "  IdentityFile " key;
                } else {
                    print $0;
                }
                if (getline <= 0) break;
            }
            if (NF > 0) print $0;
            next;
        }
        {print}
        ' "$CONFIG_FILE" > "$TMP_FILE"
        mv "$TMP_FILE" "$CONFIG_FILE"
    else
        # 添加新配置
        echo "" >> "$CONFIG_FILE"
        echo "# 由 $TOOL_NAME 工具自动添加的配置" >> "$CONFIG_FILE"
        echo "Host github-${TOOL_NAME}" >> "$CONFIG_FILE"
        echo "  HostName github.com" >> "$CONFIG_FILE"
        echo "  User git" >> "$CONFIG_FILE"
        echo "  IdentityFile $SSH_KEY_FILE" >> "$CONFIG_FILE"
        echo "  IdentitiesOnly yes" >> "$CONFIG_FILE"
    fi
    
    # 设置正确的权限
    chmod 600 "$CONFIG_FILE"
    
    # 更新仓库 URL 使用特定主机
    CUSTOM_SSH_REPO_URL=$(echo "$REPO_URL" | sed "s/git@github.com/git@github-${TOOL_NAME}/")
    
    echo "SSH 配置已更新，使用 $SSH_KEY_FILE 连接到 GitHub"
    echo "自定义仓库 URL: $CUSTOM_SSH_REPO_URL"
    
    # 如果在工作目录中，更新远程 URL
    if [ -d "$WORK_DIR/.git" ]; then
        cd "$WORK_DIR" || return 1
        git remote set-url origin "$CUSTOM_SSH_REPO_URL"
        echo "已更新仓库 URL 使用特定 SSH 配置: $CUSTOM_SSH_REPO_URL"
    fi
    
    # 测试 SSH 连接
    echo "测试 SSH 连接..."
    SSH_TEST=$(ssh -T -o IdentitiesOnly=yes -o BatchMode=yes -o StrictHostKeyChecking=accept-new "git@github-${TOOL_NAME}" 2>&1)
    
    if echo "$SSH_TEST" | grep -q "successfully authenticated"; then
        USERNAME=$(echo "$SSH_TEST" | grep -o "Hi [^!]*" | cut -d' ' -f2)
        echo "  SSH 认证成功，用户名: $USERNAME"
        return 0
    else
        echo "  SSH 认证失败，请检查 SSH 密钥和配置"
        echo "  错误信息: $SSH_TEST"
        return 1
    fi
}

# 主命令处理
case "$1" in
    "dev")
        dev
        ;;
    "publish")
        publish
        ;;
    "upgrade")
        upgrade
        ;;
    "storessh")
        storessh
        ;;
    "restoressh")
        restoressh
        ;;
    "-v")
        get_current_version
        ;;
    "-h"|"--help"|"")
        show_help
        ;;
    *)
        echo "未知命令: $1"
        show_help
        exit 1
        ;;
esac
